﻿package main

import (
	"context"
	"encoding/base64"
	"fmt"
	"image/jpeg"
	"io"
	"os"
	"path/filepath"
	"strings"
	"time"
	"unicode"

	"github.com/disintegration/imaging"
	"github.com/wailsapp/wails/v2/pkg/runtime"
)

// App struct
type App struct {
	ctx context.Context
}

// NewApp creates a new App application struct
func NewApp() *App {
	return &App{}
}

// startup is called when the app starts. The context is saved
// so we can call the runtime methods
func (a *App) startup(ctx context.Context) {
	a.ctx = ctx
}

// Greet returns a greeting for the given name
func (a *App) Greet(name string) string {
	return fmt.Sprintf("Hello %s, It's show time!", name)
}

// CompressImage compresses an image to the specified directory
func (a *App) CompressImage(srcPath, dstPath string) error {
	src, err := imaging.Open(srcPath)
	if err != nil {
		return err
	}

	// Resize the image to fit within 1920px on the longest side
	src = imaging.Fit(src, 1920, 1920, imaging.Lanczos)

	// Create the destination directory if it doesn't exist
	if err := os.MkdirAll(filepath.Dir(dstPath), 0755); err != nil {
		return err
	}

	// Create the destination file
	file, err := os.Create(dstPath)
	if err != nil {
		return err
	}
	defer file.Close()

	// Encode and save the image with 85% quality
	return jpeg.Encode(file, src, &jpeg.Options{Quality: 85})
}

// SaveAndCompressImage saves and compresses an uploaded image from base64 data
func (a *App) SaveAndCompressImage(base64Data string, originalFilename, dstPath string) error {
	// Decode the base64 data
	imageData, err := base64.StdEncoding.DecodeString(base64Data)
	if err != nil {
		return err
	}

	// Create a temporary file for the uploaded image
	tempFile, err := os.CreateTemp("", "upload-*"+filepath.Ext(originalFilename))
	if err != nil {
		return err
	}
	defer os.Remove(tempFile.Name()) // Clean up temp file
	defer tempFile.Close()

	// Write the image data to the temporary file
	if _, err := tempFile.Write(imageData); err != nil {
		return err
	}

	// Now compress the image from temp file to destination
	return a.CompressImage(tempFile.Name(), dstPath)
}

// ListPosts lists all posts in the directory with pagination and search support
func (a *App) ListPosts(directory string, page, pageSize int, search string) ([]string, int, error) {
	posts := make([]string, 0)

	// Check if directory exists
	if _, err := os.Stat(directory); os.IsNotExist(err) {
		fmt.Printf("目录不存在: %s\n", directory)
		return posts, 0, nil // Return empty list if directory doesn't exist
	}

	fmt.Printf("正在读取目录: %s\n", directory)

	// Read directory entries
	entries, err := os.ReadDir(directory)
	if err != nil {
		fmt.Printf("读取目录失败: %v\n", err)
		return nil, 0, err
	}

	fmt.Printf("目录中有 %d 个条目\n", len(entries))

	// Collect all posts first
	var allPosts []string

	// Look for date directories and direct markdown files
	for _, entry := range entries {
		if entry.IsDir() {
			// Check if the entry is a date directory (YYYY-MM-DD format)
			if isValidDatePath(entry.Name()) {
				fmt.Printf("发现日期目录: %s\n", entry.Name())
				// Read files in the date directory
				dateDirPath := filepath.Join(directory, entry.Name())
				files, err := os.ReadDir(dateDirPath)
				if err != nil {
					fmt.Printf("读取日期目录失败 %s: %v\n", dateDirPath, err)
					continue // Skip this directory if we can't read it
				}

				// Add markdown files to the list
				for _, file := range files {
					if !file.IsDir() && filepath.Ext(file.Name()) == ".md" {
						// Extract title from filename (remove .md extension)
						title := strings.TrimSuffix(file.Name(), ".md")
						fmt.Printf("  发现文章: %s (标题: %s)\n", file.Name(), title)

						// Apply search filter if provided
						if search != "" {
							// Convert both title and search term to lowercase for case-insensitive search
							lowerTitle := strings.ToLower(title)
							lowerSearch := strings.ToLower(search)

							// Check if title contains search term
							if strings.Contains(lowerTitle, lowerSearch) {
								allPosts = append(allPosts, title)
								fmt.Printf("    -> 匹配搜索条件\n")
							}
						} else {
							// No search filter, add all posts
							allPosts = append(allPosts, title)
							fmt.Printf("    -> 添加到列表\n")
						}
					}
				}
			}
		} else if !entry.IsDir() && filepath.Ext(entry.Name()) == ".md" {
			// Also check for markdown files directly in the directory (not in date folders)
			// Extract title from filename (remove .md extension)
			title := strings.TrimSuffix(entry.Name(), ".md")
			fmt.Printf("发现直接文件: %s (标题: %s)\n", entry.Name(), title)

			// Apply search filter if provided
			if search != "" {
				// Convert both title and search term to lowercase for case-insensitive search
				lowerTitle := strings.ToLower(title)
				lowerSearch := strings.ToLower(search)

				// Check if title contains search term
				if strings.Contains(lowerTitle, lowerSearch) {
					allPosts = append(allPosts, title)
					fmt.Printf("  -> 匹配搜索条件\n")
				}
			} else {
				// No search filter, add all posts
				allPosts = append(allPosts, title)
				fmt.Printf("  -> 添加到列表\n")
			}
		}
	}

	// Calculate total count
	totalCount := len(allPosts)
	fmt.Printf("总共找到 %d 篇文章\n", totalCount)

	// If no posts, return empty slice
	if totalCount == 0 {
		fmt.Printf("没有找到文章，返回空列表\n")
		return posts, 0, nil
	}

	// Calculate pagination
	if page < 1 {
		page = 1
	}
	if pageSize <= 0 {
		pageSize = 10 // Default page size
	}

	fmt.Printf("分页信息 - 页码: %d, 页面大小: %d, 总数: %d\n", page, pageSize, totalCount)

	startIndex := (page - 1) * pageSize
	endIndex := startIndex + pageSize

	// Adjust endIndex if it exceeds the total count
	if endIndex > totalCount {
		endIndex = totalCount
	}

	// If startIndex is beyond totalCount, return empty slice
	if startIndex >= totalCount {
		fmt.Printf("起始索引超出范围，返回空列表\n")
		return posts, totalCount, nil
	}

	// Extract the posts for the current page
	posts = allPosts[startIndex:endIndex]
	fmt.Printf("返回第 %d 页的数据，共 %d 篇文章\n", page, len(posts))

	// 确保返回正确的数据格式
	fmt.Printf("返回结果: posts长度=%d, totalCount=%d, error=nil\n", len(posts), totalCount)
	return posts, totalCount, nil
}

// LoadPost loads a post's content
func (a *App) LoadPost(title, directory string) (string, error) {
	// Create a safe filename based on title only
	safeTitle := strings.ToLower(title)                 // 全部转换为小写
	safeTitle = strings.ReplaceAll(safeTitle, " ", "-") // 空格替换为连字符
	safeTitle = strings.Map(func(r rune) rune {
		// 只保留字母、数字、连字符和下划线
		if unicode.IsLetter(r) || unicode.IsDigit(r) || r == '-' || r == '_' {
			return r
		}
		return -1
	}, safeTitle)

	// 限制标题长度以避免过长的文件名
	if len(safeTitle) > 50 {
		safeTitle = safeTitle[:50]
	}

	// 移除开头和结尾的连字符
	safeTitle = strings.Trim(safeTitle, "-_")

	// 如果标题变为空，使用默认名称
	if safeTitle == "" {
		safeTitle = "post"
	}

	// 创建文件名（不带日期前缀）
	filename := fmt.Sprintf("%s.md", safeTitle)

	// Check all date directories for the file
	entries, err := os.ReadDir(directory)
	if err != nil {
		return "", err
	}

	for _, entry := range entries {
		if entry.IsDir() {
			// Check if the entry is a date directory (YYYY-MM-DD format)
			if isValidDatePath(entry.Name()) {
				// Check if the file exists in this date directory
				fullPath := filepath.Join(directory, entry.Name(), filename)
				if _, err := os.Stat(fullPath); err == nil {
					// File exists, read its content
					content, err := os.ReadFile(fullPath)
					if err != nil {
						return "", err
					}
					return string(content), nil
				}
			}
		}
	}

	return "", fmt.Errorf("文章未找到: %s", title)
}

// DeletePost deletes a post and its associated images
func (a *App) DeletePost(title, directory, imageDirectory, rootDirectory string) error {
	// Create a safe filename based on title only
	safeTitle := strings.ToLower(title)                 // 全部转换为小写
	safeTitle = strings.ReplaceAll(safeTitle, " ", "-") // 空格替换为连字符
	safeTitle = strings.Map(func(r rune) rune {
		// 只保留字母、数字、连字符和下划线
		if unicode.IsLetter(r) || unicode.IsDigit(r) || r == '-' || r == '_' {
			return r
		}
		return -1
	}, safeTitle)

	// 限制标题长度以避免过长的文件名
	if len(safeTitle) > 50 {
		safeTitle = safeTitle[:50]
	}

	// 移除开头和结尾的连字符
	safeTitle = strings.Trim(safeTitle, "-_")

	// 如果标题变为空，使用默认名称
	if safeTitle == "" {
		safeTitle = "post"
	}

	// 创建文件名（不带日期前缀）
	filename := fmt.Sprintf("%s.md", safeTitle)

	// Check all date directories for the file
	entries, err := os.ReadDir(directory)
	if err != nil {
		return err
	}

	fileFound := false
	var postFilePath string
	var postDate string

	for _, entry := range entries {
		if entry.IsDir() {
			// Check if the entry is a date directory (YYYY-MM-DD format)
			if isValidDatePath(entry.Name()) {
				// Check if the file exists in this date directory
				fullPath := filepath.Join(directory, entry.Name(), filename)
				if _, err := os.Stat(fullPath); err == nil {
					// File exists
					fileFound = true
					postFilePath = fullPath
					postDate = entry.Name()
					break
				}
			}
		}
	}

	if !fileFound {
		return fmt.Errorf("文章未找到: %s", title)
	}

	// Read the post content to extract image paths
	content, err := os.ReadFile(postFilePath)
	if err != nil {
		return err
	}

	// Extract image paths from the content
	imagePaths := extractImagePaths(string(content), imageDirectory, rootDirectory)

	// Delete associated images
	for _, imagePath := range imagePaths {
		if imagePath != "" {
			// Convert relative path to absolute path
			var absoluteImagePath string
			if filepath.IsAbs(imagePath) {
				absoluteImagePath = imagePath
			} else {
				// Handle relative paths
				if rootDirectory != "" {
					absoluteImagePath = filepath.Join(rootDirectory, imagePath)
				} else {
					absoluteImagePath = filepath.Join(imageDirectory, imagePath)
				}
			}

			// Delete the image file if it exists
			if _, err := os.Stat(absoluteImagePath); err == nil {
				if err := os.Remove(absoluteImagePath); err != nil {
					fmt.Printf("Warning: Failed to delete image %s: %v\n", absoluteImagePath, err)
				}
			}
		}
	}

	// Delete the post file
	if err := os.Remove(postFilePath); err != nil {
		return err
	}

	// Check if the date directory is empty and delete it if so
	dateDir := filepath.Join(directory, postDate)
	isEmpty, err := isDirEmpty(dateDir)
	if err != nil {
		return err
	}

	if isEmpty {
		// Delete the empty date directory
		if err := os.Remove(dateDir); err != nil {
			fmt.Printf("Warning: Failed to delete empty directory %s: %v\n", dateDir, err)
		}
	}

	return nil
}

// UpdatePost updates an existing post
func (a *App) UpdatePost(oldTitle, newTitle, content, description, author, coverImagePath, directory string, tags []string, weight int) error {
	// First delete the old post (but preserve images by not passing imageDirectory/rootDirectory)
	if err := a.DeletePost(oldTitle, directory, "", ""); err != nil {
		return err
	}

	// Then save the new post
	return a.SavePost(newTitle, content, description, author, coverImagePath, directory, tags, weight)
}

// extractImagePaths extracts image paths from markdown content
func extractImagePaths(content, imageDirectory, rootDirectory string) []string {
	var imagePaths []string

	// Simple regex to find image paths in markdown
	// This is a basic implementation and might need to be enhanced based on actual usage
	lines := strings.Split(content, "\n")
	for _, line := range lines {
		// Look for markdown image syntax: ![alt](path)
		if strings.Contains(line, "![](") || strings.Contains(line, "![") {
			// Extract path between parentheses
			start := strings.Index(line, "(")
			end := strings.Index(line, ")")
			if start != -1 && end != -1 && end > start {
				path := line[start+1 : end]
				// Clean up the path
				path = strings.TrimSpace(path)
				// Remove quotes if present
				path = strings.Trim(path, "\"'")
				if path != "" {
					imagePaths = append(imagePaths, path)
				}
			}
		}
	}

	return imagePaths
}

// SelectDirectory opens a dialog to select a directory
func (a *App) SelectDirectory() (string, error) {
	return runtime.OpenDirectoryDialog(a.ctx, runtime.OpenDialogOptions{
		Title: "选择保存目录",
	})
}

// SelectImageDirectory opens a dialog to select a directory for images
func (a *App) SelectImageDirectory() (string, error) {
	return runtime.OpenDirectoryDialog(a.ctx, runtime.OpenDialogOptions{
		Title: "选择图片保存目录",
	})
}

// isDirEmpty checks if a directory is empty
func isDirEmpty(dirPath string) (bool, error) {
	f, err := os.Open(dirPath)
	if err != nil {
		return false, err
	}
	defer f.Close()

	// Read directory entries
	_, err = f.Readdirnames(1)
	if err == nil {
		// Directory is not empty
		return false, nil
	}

	if err == io.EOF {
		// Directory is empty
		return true, nil
	}

	// Other error
	return false, err
}

// isValidDatePath checks if a directory name is in YYYY-MM-DD format
func isValidDatePath(dirName string) bool {
	// Check if the directory name matches the date format
	_, err := time.Parse("2006-01-02", dirName)
	return err == nil
}

// SavePost saves a post as a markdown file
func (a *App) SavePost(title, content, description, author, coverImagePath, directory string, tags []string, weight int) error {
	// Get current date for directory
	currentDate := time.Now().Format("2006-01-02")

	// Create a safe filename based on title only
	safeTitle := createSafeFilename(title)

	// 创建基于日期的目录路径
	dateDirectory := filepath.Join(directory, currentDate)

	// 创建文件名（不带日期前缀）
	filename := fmt.Sprintf("%s.md", safeTitle)
	fullPath := filepath.Join(dateDirectory, filename)

	// 设置默认值
	if author == "" {
		author = "Aries"
	}
	if weight <= 0 {
		weight = 1
	}

	// 转义特殊字符
	escapedTitle := escapeString(title)
	escapedDescription := escapeString(description)
	escapedAuthor := escapeString(author)

	// Format tags as YAML array
	tagsFormatted := ""
	if len(tags) > 0 {
		tagsFormatted = "tags: ["
		for i, tag := range tags {
			if i > 0 {
				tagsFormatted += ", "
			}
			escapedTag := escapeString(tag)
			tagsFormatted += fmt.Sprintf("\"%s\"", escapedTag)
		}
		tagsFormatted += "]\n"
	}

	// Format author as YAML array
	authorFormatted := ""
	if escapedAuthor != "" {
		authorFormatted = fmt.Sprintf("author: [\"%s\"]\n", escapedAuthor)
	}

	// Format cover image if provided
	coverFormatted := ""
	if coverImagePath != "" {
		escapedCoverImagePath := escapeString(coverImagePath)
		coverFormatted = fmt.Sprintf("cover:\n    image: %s\n    hiddenInList: true\n", escapedCoverImagePath)
	}

	// Create disqus parameters
	disqusIdentifier := safeTitle
	disqusURL := fmt.Sprintf("https://xiaomizhou.net/%s/%s/", currentDate, safeTitle) // 需要替换为实际域名

	// Create the markdown content with enhanced front matter
	frontMatter := fmt.Sprintf("---\ntitle: \"%s\"\ndisqus_identifier: \"%s\"\ndisqus_url: \"%s\"\ndate: %s\ndescription: \"%s\"\n%s%s%sweight: %d\n---\n\n%s",
		escapedTitle, disqusIdentifier, disqusURL, currentDate, escapedDescription, tagsFormatted, authorFormatted, coverFormatted, weight, content)

	// Create the date directory if it doesn't exist
	if err := os.MkdirAll(dateDirectory, 0755); err != nil {
		return err
	}

	// Write the markdown file
	return os.WriteFile(fullPath, []byte(frontMatter), 0644)
}

// createSafeFilename creates a safe filename from a title
func createSafeFilename(title string) string {
	// Convert to lowercase
	safeTitle := strings.ToLower(title)

	// Replace spaces with hyphens
	safeTitle = strings.ReplaceAll(safeTitle, " ", "-")

	// Process each character
	var result strings.Builder
	for _, r := range safeTitle {
		// Keep letters, digits, hyphens, and underscores
		if unicode.IsLetter(r) || unicode.IsDigit(r) || r == '-' || r == '_' {
			result.WriteRune(r)
		} else if r == ' ' {
			// Convert spaces to hyphens (should already be done, but just in case)
			result.WriteRune('-')
		} else {
			// For other characters (including Chinese), convert to Pinyin or keep as-is
			// For now, we'll keep them as-is and replace with hyphens
			result.WriteRune('-')
		}
	}

	safeTitle = result.String()

	// Replace multiple consecutive hyphens with a single hyphen
	safeTitle = strings.ReplaceAll(safeTitle, "--", "-")
	safeTitle = strings.ReplaceAll(safeTitle, "--", "-") // Do it twice to handle cases like "---"

	// Limit title length to avoid overly long filenames
	if len(safeTitle) > 50 {
		safeTitle = safeTitle[:50]
	}

	// Trim leading and trailing hyphens and underscores
	safeTitle = strings.Trim(safeTitle, "-_")

	// If title becomes empty, use a default
	if safeTitle == "" {
		safeTitle = "post"
	}

	return safeTitle
}

// escapeString escapes special characters in a string for YAML
func escapeString(s string) string {
	// Escape backslashes first
	s = strings.ReplaceAll(s, "\\", "\\\\")
	// Escape double quotes
	s = strings.ReplaceAll(s, "\"", "\\\"")
	return s
}

// CheckTitleDuplicate checks if a post with the same title already exists in the directory
func (a *App) CheckTitleDuplicate(title, directory string) (bool, string, error) {
	// Create a safe filename based on title only
	safeTitle := createSafeFilename(title)

	// 创建文件名（不带日期前缀）
	filename := fmt.Sprintf("%s.md", safeTitle)

	// Check all date directories for the file
	entries, err := os.ReadDir(directory)
	if err != nil {
		return false, "", err
	}

	for _, entry := range entries {
		if entry.IsDir() {
			// Check if the entry is a date directory (YYYY-MM-DD format)
			if isValidDatePath(entry.Name()) {
				// Check if the file exists in this date directory
				fullPath := filepath.Join(directory, entry.Name(), filename)
				if _, err := os.Stat(fullPath); err == nil {
					// File exists
					return true, fullPath, nil
				}
			}
		}
	}

	return false, "", nil
}

